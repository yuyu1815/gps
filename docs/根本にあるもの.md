# **Android屋内測位アプリ開発バイブル（最終版）**

## **0. はじめに：屋内測位の「理想」と「現実」**

このガイドは、BLEビーコンとAndroidスマートフォンのセンサーを利用して、高精度な屋内測位アプリを開発するための実践的な手順書です。

しかし、その前に最も重要な事実を理解する必要があります。屋内測位の理論はシンプルに見えますが、**現実世界の物理的な制約が大きな壁**として立ちはだかります。このガイドで紹介する多くの高度なテクニックは、これらの課題を克服するために存在します。

### **現実世界の三大課題**

1. **RSSIの激しい揺らぎ:** BLEの電波強度（RSSI）は、人や物の動き、ドアの開閉、他の無線機器からの干渉といった僅かな環境変化で、常に激しく変動します。生データをそのまま距離に変換すると、推定位置は暴れまわります。
    * **対策 → フィルタリング技術**
2. **地磁気の歪み:** 屋内は鉄骨、エレベーター、配電盤、PC、什器など、磁場を乱すノイズ源で溢れています。スマートフォンのコンパス（地磁気センサー）はほとんどの場合、正確な方角を示しません。これを無視して歩行追跡を行うと、数歩で破綻します。
    * **対策 → ジャイロセンサーを主体とした姿勢推定フィルタ**
3. **マルチパス問題:** 電波が壁や床、天井で反射し、複数の経路を辿って受信機に到達します。これにより、直接波ではない回り込んだ電波を拾ってしまい、距離計算に大きな誤差が生じます。
    * **対策 → 堅牢な測位アルゴリズムとセンサーフュージョン**

これらの課題を念頭に置き、本ガイドを読み進めてください。

## **1. オフライン開発環境の完全準備**

オフラインになる前に、ソフトウェア、ライブラリ、そして**ドキュメント**を完全にローカル環境に揃えます。

### **1.1. 必須ソフトウェアとSDK**

* **Android Studio:** 最新の安定版。
* **JDK (Java Development Kit):** Android Studioに同梱。
* **Android SDK:** SDK Managerから、対象APIレベルのPlatform、Build-Tools、Platform-Tools、Emulator、そして高度な計算用にNDKをダウンロードします。

### **1.2. Gradleとライブラリ（拡充版）**

一度オンラインでプロジェクトをビルドし、必要なライブラリをPCにキャッシュさせます。
```kotlin
// build.gradle.kts (Module :app)

dependencies {  
// ... 標準ライブラリ ...
  // 数学的な計算（最小二乗法など）で使用する可能性  
  implementation("org.apache.commons:commons-math3:3.6.1")

  // デバッグ時のデータ可視化に極めて有用  
  implementation("com.github.PhilJay:MPAndroidChart:v3.1.0")

  // ログ出力の定番。ファイルへの出力も可能  
  implementation("com.jakewharton.timber:timber:5.0.1")  
}  
```
Sync Now` を実行後、`File > Settings > Build, Execution, Deployment > Build Tools > Gradle`で`Offline work`を有効にします。

### 1.3. ドキュメントのオフライン化（最重要）

オフライン環境では検索ができません。以下をローカルに保存しておくことが、開発効率を大きく左右します。  
* **Android Developer公式サイト:** `BluetoothLeScanner`, `SensorManager` など、関連クラスのページをHTMLとして保存。  
* **ライブラリのJavadoc:** `MPAndroidChart`などの外部ライブラリのドキュメントやリポジトリのWikiをクローンまたはダウンロードしておきます。

---

## 2. プロジェクトの設計と実装

### 2.1. 権限の設定 (`AndroidManifest.xml`)

(変更なし)

### 2.2. BLEビーコンのスキャン

#### 2.2.1. ビーコンの有効期限（Staleness）管理

スキャン結果を保持するマップは、古い情報を削除し続けないと、ユーザーがビーコンから離れてもその場にいるかのような誤動作をします。

```kotlin  
data class BeaconScanResult(val result: ScanResult, val timestamp: Long)

private val discoveredBeacons = mutableMapOf<String, BeaconScanResult>()  
private const val BEACON_TIMEOUT_MS = 5000 // 5秒以上更新がなければ無効とみなす

// ScanCallback内で結果を処理する際  
result?.let {  
discoveredBeacons[it.device.address] = BeaconScanResult(it, System.currentTimeMillis())  
}

// 位置計算の直前に、古いビーコンを掃除する  
fun cleanupOldBeacons() {  
  val now = System.currentTimeMillis()  
  val iterator = discoveredBeacons.entries.iterator()  
  while (iterator.hasNext()) {  
    val entry = iterator.next()  
    if (now - entry.value.timestamp > BEACON_TIMEOUT_MS) {  
      iterator.remove()  
    }  
  }  
}
```
### **2.3. 距離の推定 (RSSIから)**

#### **2.3.1. RSSIのフィルタリング**

生のRSSIは使わず、必ずフィルタを通します。実装が容易で効果の高い**移動平均フィルタ**を導入します。
```kotlin
// ビーコンごとのRSSI履歴を保持  
private val rssiHistory = mutableMapOf<String, MutableList<Int>>()  
private const val RSSI_HISTORY_SIZE = 5 // 過去5回分の平均

fun getFilteredRssi(address: String, newRssi: Int): Double {  
  val history = rssiHistory.getOrPut(address) { mutableListOf() }  
  history.add(newRssi)  
  if (history.size > RSSI_HISTORY_SIZE) {  
    history.removeAt(0)  
  }  
  return history.average()  
}
```
**警告:** 環境係数Nは、2.0のような固定値では**絶対に精度が出ません**。これは現場で必ず調整が必要な最重要キャリブレーションパラメータです。

### **2.4. 位置の計算**

#### **2.4.1. ビーコン配置の重要性 (GDOP)**

測位精度はビーコンの配置に大きく依存します。

* **良い配置:** 対象エリアを囲むように、大きな三角形を形成する。
* **悪い配置:** 一直線上に並んでいる。（この場合、特定方向への誤差が極端に大きくなる）

この精度の劣化度合いを**GDOP (Geometric Dilution of Precision)**と呼びます。

#### **2.4.2. より堅牢なアルゴリズム：最小二乗法**

加重重心法はシンプルですが、ビーコン数が少ない場合や配置が悪い場合に脆弱です。よりロバストな手法として**最小二乗法 (Least Squares Method)** があります。

これは、N個のビーコン (xi, yi) からの距離 di の観測方程式 (x - xi)^2 + (y - yi)^2 = di^2 を連立させ、全体の誤差が最小になるような (x, y) を解析的に見つける手法です。commons-math3ライブラリなどが役立ちます。

### **2.5. 歩行者自律航法 (PDR)**

#### **2.5.1. 堅牢な歩行検出**

単純なしきい値法は誤検出が多いため、以下の手順を踏みます。

1. **ノイズ除去:** 加速度データにローパスフィルタを適用します。
2. **ピーク・谷検出:** 単純なしきい値ではなく、明確な「山」と「谷」のパターンを検出します。
3. **歩行周期の考慮:** 歩行は一定のリズム（0.5秒〜2秒に1歩）を持つため、極端に短い間隔で発生したピークはノイズとして棄却します。

#### **2.5.2. 歩行方向：ジャイロ主体への転換（最重要修正）**

**地磁気センサー（コンパス）は屋内では信頼できません。** ジャイロセンサーを主体とした**姿勢推定フィルタ**が必須です。

* **基本方針:**
    1. **短期的姿勢:** ジャイロセンサーの角速度を時間で積分し、前の姿勢からの変化を高速に計算します。これにより、滑らかな動きを実現します。
    2. **長期的補正:** ジャイロには必ず**ドリフト（時間経過に伴う誤差の蓄積）**が発生します。これを、加速度センサー（重力方向を教えてくれる）と、信頼できる時だけ地磁気センサーを使って、ゆっくりと補正します。
* **実装:** このフュージョンを実現するのが**相補フィルタ**や**マドグウィックフィルタ**、**カルマンフィルタ**です。相補フィルタは実装が比較的容易で効果が高いため、最初のステップとして推奨されます。  
```kotlin
// ジャイロから取得した角速度(rad/s)と前回の更新からの経過時間(s)で向きを更新  
private var currentHeading = 0.0f // 現在の方位 (ラジアン)  
private var lastTimestamp: Long = 0

fun onGyroscopeChanged(event: SensorEvent) {  
if (lastTimestamp == 0L) {  
  lastTimestamp = event.timestamp  
  return  
}  
val dt = (event.timestamp - lastTimestamp) * 1.0e-9f // nsからsへ変換  
lastTimestamp = event.timestamp

    // Z軸周りの角速度を積分  
    currentHeading += event.values[2] * dt  
}
```
  注釈：プロダクトレベルの実装に向けて  
  このコードは、デバイスが水平に保たれている場合の基本的な積分原理を示しています。実際のプロダクトでは、デバイスがどのような向き（縦持ち、ポケットの中など）であっても正確に方位を追跡する必要があります。そのためには、Androidの TYPE_ROTATION_VECTOR センサー（内部でジャイロ、加速度、地磁気をフュージョンしている）を利用するか、より高度な姿勢推定フィルタ（例: Madgwickフィルタ、相補フィルタ）を自前で実装することを推奨します。

#### **2.5.3. 歩幅の動的推定**

歩幅を固定値にすると、歩く速さが変わるだけで誤差が累積します。より高度な手法として、歩行周期や加速度の大きさから歩幅を動的に推定するアルゴリズム（例: Weinberg法）も存在します。

### **2.6. センサーフュージョン**

#### **2.6.1. UXを損なわない滑らかな補正**

BLEの測位結果にPDRの位置を突然「引き戻す」と、ユーザー視点では位置がジャンプして見えます。これを避けるため、**重み付け平均**で滑らかに補正します。
```kotlin
// PDRによる推定位置: pdrPosition  
// BLEによる測位結果: blePosition  
// α: 信頼度に基づく重み (0.0 < α < 1.0)  
fusedPosition = (1 - α) * pdrPosition + α * blePosition
```
重みαは、BLE測位の信頼度（例: 検出ビーコン数が多い、分散が小さいほどαを大きくする）に応じて動的に変更するのが理想です。

#### **2.6.2. カルマンフィルタへの道**

カルマンフィルタは究極的な解決策の一つですが、状態方程式や観測方程式の設計など、線形代数と確率統計の知識を要します。まずは上記の単純なフュージョンを実装し、その限界を理解してから挑戦することを強く推奨します。

#### **2.6.3. コラム：カルマンフィルタが真価を発揮する時**

重み付け平均によるフュージョンは、位置の「補正」に優れています。一方、カルマンフィルタは、位置だけでなく**「速度」や「加速度」**といったシステムの「状態（State）」も同時に推定できます。

これにより、「ユーザーが現在どちらの方向に、どのくらいの速度で移動しているか」をより滑らかに**予測**できるようになります。その結果、PDRの歩行追跡がさらに安定し、アイコンの動きがより自然で物理法則に沿ったものになります。

**単なる位置補正以上の、滑らかな移動予測を実現したくなった時が、カルマンフィルタ導入のタイミングです。**

### **2.7. UIの実装**

#### **2.7.1. 座標系の管理**

初心者が最も嵌る罠の一つが座標系の不一致です。

* **物理座標系:** (x, y) メートル単位。ビーコンの設置場所。
* **論理座標系:** アプリ内部で扱う座標。物理座標と同じでも良い。
* **描画座標系:** (x, y) ピクセル単位。画面上の表示位置。

これらのマッピング（拡大・縮小・平行移動）を管理する専用クラス CoordinateTransformer を設計し、すべての座標変換をそこに集約すべきです。

## **3. マップとビーコンの構成管理**

ビーコンの座標やマップ画像をハードコーディングするのではなく、**JSONファイル**で外部から読み込めるように設計します。これにより、現場での調整が格段に楽になります。

**例: map_config.json**
```json
{  
  "map_name": "Office_Floor_1",  
  "image_file": "floor1.png",  
  "width_meters": 50.0,  
  "height_meters": 30.0,  
  "beacons": [  
    { "mac_address": "00:11:22:33:44:AA", "x": 2.5, "y": 5.0, "tx_power": -59 },  
    { "mac_address": "00:11:22:33:44:BB", "x": 45.0, "y": 15.0, "tx_power": -61 },  
    { "mac_address": "00:11:22:33:44:CC", "x": 25.0, "y": 28.0, "tx_power": -60 }  
  ]  
}
```
## **4. 必須ツール：デバッグとデータ分析**

**開発効率は、デバッグ機能の有無で10倍以上変わります。**

### **4.1. デバッグビューの実装**

開発中は、画面に以下の情報を常時表示するデバッグ用のオーバーレイビューが必須です。

* 検出中の各ビーコンのMACアドレス、生RSSI、フィルタ後RSSI、計算距離
* 現在の歩数、歩行方向（Heading）、PDRによる位置
* BLEによる計算位置、最終的なフュージョン位置
* センサーの生データ（MPAndroidChartでグラフ表示するのが理想）

### **4.2. データロギングと再生機能**

アルゴリズム改善の生命線です。

* **ロギング:** 実地テスト中の全てのセンサーデータ（加速度、ジャイロ、磁気）とBLEスキャン結果を、タイムスタンプ付きでCSVファイルなどに保存する機能を実装します。
* **再生:** 保存したログファイルをアプリで読み込み、測位の様子を再生できる機能を実装します。これにより、オフィスに戻ってから何度もアルゴリズムを試行錯誤できます。

## **5. テスト、キャリブレーション、評価**

### **5.1. キャリブレーション**

* **TxPower:** 各ビーコンから1m離れた場所でRSSIを測定し、その平均値を求めます。
* **環境係数N:** 現場で既知の距離を歩き、推定距離と一致するように調整します。

### **5.2. 評価手法**

「なんとなく合っている」で終わらせず、定量的に評価します。

1. **グラウンドトゥルース（正解経路）の準備:** 床にメジャーで線を引き、その上を歩くなどして、時刻ごとの正確な位置がわかるテストデータを作成します。
2. **評価指標:** アプリが推定した経路と正解経路を比較し、**RMSE (二乗平均平方根誤差)** を計算します。これにより、アルゴリズム改善の効果を客観的に判断できます。

RMSE=n1​i=1∑n​((xi​−x^i​)2+(yi​−y^​i​)2)​

## **6. プロダクト化への道：UXとパフォーマンス**

ここまでの実装は、測位ロジックの確立に焦点を当ててきました。最終的なプロダクトの品質は、ユーザー体験（UX）とパフォーマンスによって決まります。

### **6.1. UI/UX：不確実性の可視化**

測位システムは常に誤差を含みます。その「不確実性」をユーザーに正直に伝えることが、アプリへの信頼を築きます。

* **実装案:** ユーザーの現在位置を単なる「点」で表示するのではなく、**「半透明の円」**で表現します。
* **円の半径の意味:** この半径は、システムの「不確実性（誤差の可能性の大きさ）」を表します。
    * **円が小さい時（高信頼度）:** 多くのビーコンから安定した信号を受信できている状態。
    * **円が大きい時（低信頼度）:** 利用可能なビーコンが少ない、またはRSSIのばらつきが大きい状態。

これにより、ユーザーは「今は精度が高い」「今は少しずれているかもしれない」というシステムの状況を直感的に理解でき、より賢くアプリを使いこなせます。

### **6.2. パフォーマンス：バッテリー消費への配慮**

最高の精度を求める設定は、バッテリーを大量に消費します。実用化には最適化が不可欠です。

* **静止検出:** 加速度センサーの値が一定時間変化なければ「静止状態」と判断し、ジャイロリスナーやBLEスキャンを停止、または間欠動作（例: 10秒に1回）に切り替えます。
* **動的スキャン:** 移動速度が速い時は高頻度スキャン、遅い時は低頻度にするなど、状況に応じてスキャン間隔を動的に変更します。

## **7. 運用とメンテナンス：システムを生き長らえさせるために**

優れたシステムを開発することと、そのシステムを長期間安定して稼働させることは、全く異なる挑戦です。この章は、開発の領域を超え、システムを実世界で運用するための指針を示します。

### **7.1. 設置担当者向け簡易マニュアルの重要性**

開発者が常に現場に立ち会えるとは限りません。ビーコンを設置する現地スタッフは、技術者ではない可能性が高いです。彼らがミスなく作業できるよう、誰が読んでも間違いようのない、写真付きのシンプルなチェックリストを用意することが、システムの初期精度を保証します。

**簡易マニュアルに含めるべき項目例：**

* **何を？:** config.jsonに記載されたMACアドレス AA:BB:.. のビーコン。
* **どこに？:** 地図上のポイント B-3（x=1.5, y=8.0）の壁。
* **どうやって？**
    1. ビーコンの電源を入れます。
    2. 指定された壁の、床から1.8mの高さに、付属の両面テープで貼り付けます。
    3. ビーコンのロゴが部屋の中央を向くように設置します。
    4. 管理用アプリの「設置チェック」をタップし、ビーコンが緑色に表示されることを確認します。

このような非技術者向けの配慮が、設計通りの物理環境を構築する鍵となります。

### **7.2. ビーコンの死活監視（ヘルスチェック）**

ビーコンは電池で動き、電池は必ず切れます。「最近、精度が悪い」という問題の多くは、いくつかのビーコンが沈黙していることが原因です。

* 実装案:  
  測位データを収集・管理するサーバーサイド、または管理用のアプリに、ビーコンの死活監視機能を実装します。  
  最後にそのビーコンの電波を検出してから24時間以上経過した場合、管理画面や担当者への通知で「警告: ビーコン AA:BB:.. (設置場所: 1階エントランス)が応答しません。電池交換または本体の確認が必要です」といった具体的なアラートを発します。

この機能がなければ、システムは誰にも気づかれずに静かに劣化し、信頼を失っていきます。

### **7.3. 再キャリブレーションのタイミング**

一度キャリブレーションすれば終わり、ではありません。環境は変化し、それに伴い電波環境も変化します。どのような時に再キャリブレーションを検討すべきか、明確なトリガーを定義しておくことが重要です。

* **再キャリブレーションを検討すべきトリガー:**
    * **物理的なレイアウト変更:** オフィスの大規模な模様替え、新しいパーテーションや大型什器の設置など、電波の反射・遮蔽に影響を与える変更があった場合。
    * **パフォーマンスの定量的劣化:** 第5章で定めた**RMSE**を定期的に（例: 月に一度）測定し、その値が初期のベースラインから**20%以上悪化**した場合。
    * **定期メンテナンス:** 重大な変更がなくとも、**半年に一度**など、定期的な精度チェックと再キャリブレーションを運用計画に組み込む。

このバイブルが、屋内測位システムの開発から実運用、そして長期的な維持管理までを網羅する、真に完璧な一冊となり、あなたの挑戦的なプロジェクトを成功に導くことを確信しています。