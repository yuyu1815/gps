package com.example.myapplication.domain.usecase.pdr

import com.example.myapplication.domain.model.SensorData
import com.example.myapplication.domain.usecase.UseCase
import timber.log.Timber
import kotlin.math.abs
import kotlin.math.sqrt

/**
 * Use case for detecting steps using the peak-valley pattern in accelerometer data.
 * 
 * This implementation uses a peak-valley detection algorithm that identifies steps
 * by looking for significant peaks and valleys in the acceleration magnitude.
 * 
 * The algorithm works as follows:
 * 1. Calculate the magnitude of the acceleration vector
 * 2. Apply a low-pass filter to smooth the signal
 * 3. Detect peaks and valleys in the filtered signal
 * 4. Identify steps based on peak-valley patterns that meet certain criteria
 */
class DetectStepUseCase : UseCase<DetectStepUseCase.Params, DetectStepUseCase.Result> {
    
    // Import constants from StepDetectionUtils
    private val NANOS_TO_MILLIS = StepDetectionUtils.NANOS_TO_MILLIS
    
    // State variables for step detection
    private var lastAccelMagnitude = 0f
    private var filteredAccelMagnitude = 0f
    private var lastPeakValue = 0f
    private var lastValleyValue = 0f
    private var lastPeakTime = 0L
    private var lastValleyTime = 0L
    private var lastStepTime = 0L
    private var inPeak = false
    private var stepCount = 0
    
    override suspend fun invoke(params: Params): Result {
        // Extract accelerometer data
        val accelData = params.accelerometerData
        val timestamp = accelData.timestamp
        
        // Calculate acceleration magnitude
        val accelMagnitude = accelData.magnitude()
        
        // Apply low-pass filter to smooth the signal
        filteredAccelMagnitude = applyLowPassFilter(
            currentValue = accelMagnitude, 
            lastFilteredValue = filteredAccelMagnitude, 
            alpha = params.filterAlpha
        )
        
        // Detect step based on peak-valley pattern
        val stepDetected = detectStep(
            accelMagnitude = filteredAccelMagnitude,
            timestamp = timestamp,
            peakThreshold = params.peakThreshold,
            valleyThreshold = params.valleyThreshold,
            minPeakValleyHeight = params.minPeakValleyHeight,
            minStepInterval = params.minStepInterval,
            maxStepInterval = params.maxStepInterval
        )
        
        // Update last acceleration magnitude
        lastAccelMagnitude = accelMagnitude
        
        // If a step is detected, increment step count
        if (stepDetected) {
            stepCount++
            Timber.d("Step detected! Total steps: $stepCount")
        }
        
        return Result(
            stepDetected = stepDetected,
            stepCount = stepCount,
            filteredAcceleration = filteredAccelMagnitude,
            timestamp = timestamp
        )
    }
    
    /**
     * Applies a low-pass filter to smooth the acceleration signal.
     * 
     * @param currentValue Current acceleration magnitude
     * @param lastFilteredValue Last filtered acceleration magnitude
     * @param alpha Filter coefficient (0-1, lower values = more smoothing)
     * @return Filtered acceleration magnitude
     */
    private fun applyLowPassFilter(currentValue: Float, lastFilteredValue: Float, alpha: Float): Float {
        return StepDetectionUtils.applyLowPassFilter(currentValue, lastFilteredValue, alpha)
    }
    
    /**
     * Detects steps based on peak-valley patterns in the acceleration signal.
     * 
     * @param accelMagnitude Current filtered acceleration magnitude
     * @param timestamp Current timestamp
     * @param peakThreshold Threshold for peak detection
     * @param valleyThreshold Threshold for valley detection
     * @param minPeakValleyHeight Minimum height difference between peak and valley
     * @param minStepInterval Minimum time between steps (ms)
     * @param maxStepInterval Maximum time between steps (ms)
     * @return True if a step is detected, false otherwise
     */
    private fun detectStep(
        accelMagnitude: Float,
        timestamp: Long,
        peakThreshold: Float,
        valleyThreshold: Float,
        minPeakValleyHeight: Float,
        minStepInterval: Long,
        maxStepInterval: Long
    ): Boolean {
        var stepDetected = false
        
        // Convert timestamp from nanoseconds to milliseconds for easier comparison
        val timeMs = timestamp / NANOS_TO_MILLIS
        
        // Detect peaks and valleys
        if (isPeakDetected(accelMagnitude, peakThreshold)) {
            // Transition from valley to peak
            inPeak = true
            lastPeakValue = accelMagnitude
            lastPeakTime = timeMs
            
            // Check if we have a valid peak-valley pattern
            if (isValidStepPattern(timeMs, lastPeakValue, lastValleyValue, minPeakValleyHeight, minStepInterval, maxStepInterval)) {
                // Step detected!
                stepDetected = true
                lastStepTime = timeMs
                
                Timber.d("Step detected at $timeMs ms, peak-valley height: ${lastPeakValue - lastValleyValue}")
            }
        } else if (isValleyDetected(accelMagnitude, valleyThreshold)) {
            // Transition from peak to valley
            inPeak = false
            lastValleyValue = accelMagnitude
            lastValleyTime = timeMs
        }
        
        return stepDetected
    }
    
    /**
     * Determines if a peak is detected in the acceleration signal.
     * 
     * @param accelMagnitude Current acceleration magnitude
     * @param peakThreshold Threshold for peak detection
     * @return True if a peak is detected, false otherwise
     */
    private fun isPeakDetected(accelMagnitude: Float, peakThreshold: Float): Boolean {
        return !inPeak && accelMagnitude > peakThreshold && accelMagnitude > lastAccelMagnitude
    }
    
    /**
     * Determines if a valley is detected in the acceleration signal.
     * 
     * @param accelMagnitude Current acceleration magnitude
     * @param valleyThreshold Threshold for valley detection
     * @return True if a valley is detected, false otherwise
     */
    private fun isValleyDetected(accelMagnitude: Float, valleyThreshold: Float): Boolean {
        return inPeak && accelMagnitude < valleyThreshold && accelMagnitude < lastAccelMagnitude
    }
    
    /**
     * Determines if the current peak-valley pattern represents a valid step.
     * 
     * @param currentTime Current time in milliseconds
     * @param peakValue Peak acceleration value
     * @param valleyValue Valley acceleration value
     * @param minPeakValleyHeight Minimum height difference between peak and valley
     * @param minStepInterval Minimum time between steps (ms)
     * @param maxStepInterval Maximum time between steps (ms)
     * @return True if the pattern represents a valid step, false otherwise
     */
    private fun isValidStepPattern(
        currentTime: Long,
        peakValue: Float,
        valleyValue: Float,
        minPeakValleyHeight: Float,
        minStepInterval: Long,
        maxStepInterval: Long
    ): Boolean {
        val peakValleyHeight = peakValue - valleyValue
        val timeSinceLastStep = currentTime - lastStepTime
        
        return valleyValue > 0 && 
               peakValleyHeight >= minPeakValleyHeight &&
               timeSinceLastStep >= minStepInterval &&
               timeSinceLastStep <= maxStepInterval
    }
    
    /**
     * Resets the step detection state.
     */
    fun reset() {
        lastAccelMagnitude = 0f
        filteredAccelMagnitude = 0f
        lastPeakValue = 0f
        lastValleyValue = 0f
        lastPeakTime = 0L
        lastValleyTime = 0L
        lastStepTime = 0L
        inPeak = false
        stepCount = 0
    }
    
    /**
     * Parameters for the DetectStepUseCase.
     *
     * @param accelerometerData Accelerometer data
     * @param filterAlpha Low-pass filter coefficient (0-1)
     * @param peakThreshold Threshold for peak detection
     * @param valleyThreshold Threshold for valley detection
     * @param minPeakValleyHeight Minimum height difference between peak and valley
     * @param minStepInterval Minimum time between steps (ms)
     * @param maxStepInterval Maximum time between steps (ms)
     */
    data class Params(
        val accelerometerData: SensorData.Accelerometer,
        val filterAlpha: Float = StepDetectionUtils.DEFAULT_ACCEL_FILTER_ALPHA,
        val peakThreshold: Float = StepDetectionUtils.DEFAULT_PEAK_THRESHOLD,
        val valleyThreshold: Float = StepDetectionUtils.DEFAULT_VALLEY_THRESHOLD,
        val minPeakValleyHeight: Float = StepDetectionUtils.DEFAULT_MIN_PEAK_VALLEY_HEIGHT,
        val minStepInterval: Long = StepDetectionUtils.DEFAULT_MIN_STEP_INTERVAL,  // 250ms = max 4 steps per second
        val maxStepInterval: Long = StepDetectionUtils.DEFAULT_MAX_STEP_INTERVAL  // 2000ms = min 0.5 steps per second
    )
    
    /**
     * Result of the step detection.
     *
     * @param stepDetected True if a step was detected
     * @param stepCount Total number of steps detected
     * @param filteredAcceleration Filtered acceleration magnitude
     * @param timestamp Timestamp of the detection
     */
    data class Result(
        val stepDetected: Boolean,
        val stepCount: Int,
        val filteredAcceleration: Float,
        val timestamp: Long
    )
}

/**
 * Use case for detecting steps using a more advanced algorithm that combines
 * accelerometer and gyroscope data for improved accuracy.
 * 
 * This implementation uses a state machine approach with multiple conditions
 * to reduce false positives and better handle different walking patterns.
 */
class AdvancedStepDetectionUseCase : UseCase<AdvancedStepDetectionUseCase.Params, AdvancedStepDetectionUseCase.Result> {
    
    // Step detection state machine states
    private enum class State {
        IDLE,       // Waiting for initial acceleration
        RISING,     // Acceleration rising
        PEAK,       // At peak acceleration
        FALLING,    // Acceleration falling
        VALLEY      // At valley (minimum acceleration)
    }
    
    // State variables
    private var state = State.IDLE
    private var stepCount = 0
    private var lastStepTime = 0L
    private var peakValue = 0f
    private var valleyValue = 0f
    private var lastFilteredAccel = 0f
    private var lastFilteredGyro = 0f
    private var peakTime = 0L
    private var valleyTime = 0L
    
    // Window of recent acceleration values for adaptive thresholding
    private val recentAccelValues = ArrayDeque<Float>(WINDOW_SIZE)
    
    override suspend fun invoke(params: Params): Result {
        // Extract sensor data
        val accelData = params.accelerometerData
        val gyroData = params.gyroscopeData
        val timestamp = accelData.timestamp
        
        // Calculate magnitudes
        val accelMagnitude = accelData.magnitude()
        val gyroMagnitude = gyroData?.magnitude() ?: 0f
        
        // Apply low-pass filters
        val filteredAccel = applyLowPassFilter(accelMagnitude, lastFilteredAccel, params.accelFilterAlpha)
        val filteredGyro = if (gyroData != null) {
            applyLowPassFilter(gyroMagnitude, lastFilteredGyro, params.gyroFilterAlpha)
        } else {
            0f
        }
        
        // Update recent acceleration values for adaptive thresholding
        if (recentAccelValues.size >= WINDOW_SIZE) {
            recentAccelValues.removeFirst()
        }
        recentAccelValues.addLast(filteredAccel)
        
        // Calculate adaptive thresholds
        val (adaptivePeakThreshold, adaptiveValleyThreshold) = calculateAdaptiveThresholds(
            params.peakThreshold,
            params.valleyThreshold
        )
        
        // Detect step using state machine
        val stepDetected = detectStepWithStateMachine(
            filteredAccel,
            filteredGyro,
            timestamp,
            adaptivePeakThreshold,
            adaptiveValleyThreshold,
            params.minPeakValleyHeight,
            params.minStepInterval,
            params.maxStepInterval,
            params.gyroThreshold,
            params.minPeakDuration,
            params.maxPeakDuration
        )
        
        // Update last filtered values
        lastFilteredAccel = filteredAccel
        lastFilteredGyro = filteredGyro
        
        // If a step is detected, increment step count
        if (stepDetected) {
            stepCount++
            Timber.d("Step detected (advanced)! Total steps: $stepCount")
        }
        
        return Result(
            stepDetected = stepDetected,
            stepCount = stepCount,
            filteredAcceleration = filteredAccel,
            filteredGyroMagnitude = filteredGyro,
            currentState = state.name,
            timestamp = timestamp
        )
    }
    
    /**
     * Applies a low-pass filter to smooth the signal.
     * 
     * @param currentValue Current value to be filtered
     * @param lastFilteredValue Previous filtered value
     * @param alpha Filter coefficient (0-1, lower values = more smoothing)
     * @return Filtered value
     */
    private fun applyLowPassFilter(currentValue: Float, lastFilteredValue: Float, alpha: Float): Float {
        return alpha * currentValue + (1 - alpha) * lastFilteredValue
    }
    
    /**
     * Calculates adaptive thresholds based on recent acceleration values.
     * 
     * This method dynamically adjusts the peak and valley thresholds based on the
     * statistical properties (median and interquartile range) of recent acceleration values.
     * This helps the step detection algorithm adapt to different walking patterns and
     * sensor characteristics.
     * 
     * @param basePeakThreshold Base threshold for peak detection
     * @param baseValleyThreshold Base threshold for valley detection
     * @return Pair of adjusted peak and valley thresholds
     */
    private fun calculateAdaptiveThresholds(basePeakThreshold: Float, baseValleyThreshold: Float): Pair<Float, Float> {
        if (recentAccelValues.size < WINDOW_SIZE / 2) {
            return Pair(basePeakThreshold, baseValleyThreshold)
        }
        
        // Calculate median and IQR using a more efficient approach
        val sortedValues = recentAccelValues.sorted()
        val size = sortedValues.size
        
        // Calculate median - handle even-sized lists properly
        val median = if (size % 2 == 0) {
            (sortedValues[size / 2 - 1] + sortedValues[size / 2]) / 2f
        } else {
            sortedValues[size / 2]
        }
        
        // Calculate quartiles more accurately
        val q1Index = (size * 0.25f).toInt()
        val q3Index = (size * 0.75f).toInt()
        val q1 = sortedValues[q1Index]
        val q3 = sortedValues[q3Index]
        val iqr = q3 - q1
        
        // Calculate standard deviation for additional signal characteristics
        val mean = sortedValues.average().toFloat()
        val stdDev = sqrt(sortedValues.map { (it - mean) * (it - mean) }.sum() / size)
        
        // Adjust thresholds based on signal characteristics with improved weighting
        // Use both IQR and standard deviation for more robust thresholds
        val adaptivePeakThreshold = median + (iqr * 1.2f + stdDev * 0.8f) / 2f
        val adaptiveValleyThreshold = median - (iqr * 1.2f + stdDev * 0.8f) / 2f
        
        // Ensure thresholds are within reasonable bounds with wider range for more adaptability
        val finalPeakThreshold = adaptivePeakThreshold.coerceIn(
            basePeakThreshold * 0.6f,
            basePeakThreshold * 1.4f
        )
        
        val finalValleyThreshold = adaptiveValleyThreshold.coerceIn(
            baseValleyThreshold * 0.6f,
            baseValleyThreshold * 1.4f
        )
        
        Timber.v("Adaptive thresholds: peak=$finalPeakThreshold, valley=$finalValleyThreshold (base: peak=$basePeakThreshold, valley=$baseValleyThreshold)")
        return Pair(finalPeakThreshold, finalValleyThreshold)
    }
    
    /**
     * Detects steps using an enhanced state machine approach.
     * 
     * This method implements a state machine with five states (IDLE, RISING, PEAK, FALLING, VALLEY)
     * to detect steps based on acceleration patterns. It incorporates gyroscope data
     * to reduce false positives and includes additional validation checks for improved accuracy.
     * 
     * The state transitions are:
     * 1. IDLE → RISING: When acceleration exceeds peak threshold
     * 2. RISING → PEAK: When acceleration starts decreasing after rising
     * 3. PEAK → FALLING: When acceleration drops below valley threshold
     * 4. FALLING → VALLEY: When acceleration starts increasing after falling
     * 5. VALLEY → IDLE: After step detection logic is applied
     * 
     * @param accelMagnitude Current filtered acceleration magnitude
     * @param gyroMagnitude Current filtered gyroscope magnitude
     * @param timestamp Current timestamp in nanoseconds
     * @param peakThreshold Threshold for peak detection
     * @param valleyThreshold Threshold for valley detection
     * @param minPeakValleyHeight Minimum height difference between peak and valley
     * @param minStepInterval Minimum time between steps (ms)
     * @param maxStepInterval Maximum time between steps (ms)
     * @param gyroThreshold Minimum gyroscope magnitude required for step validation
     * @param minPeakDuration Minimum duration of a peak (ms)
     * @param maxPeakDuration Maximum duration of a peak (ms)
     * @return True if a step is detected, false otherwise
     */
    private fun detectStepWithStateMachine(
        accelMagnitude: Float,
        gyroMagnitude: Float,
        timestamp: Long,
        peakThreshold: Float,
        valleyThreshold: Float,
        minPeakValleyHeight: Float,
        minStepInterval: Long,
        maxStepInterval: Long,
        gyroThreshold: Float,
        minPeakDuration: Long,
        maxPeakDuration: Long
    ): Boolean {
        var stepDetected = false
        
        // Convert timestamp from nanoseconds to milliseconds
        val timeMs = timestamp / 1_000_000
        
        // State machine for step detection
        when (state) {
            State.IDLE -> {
                // Enhanced condition: require sustained acceleration above threshold
                if (accelMagnitude > peakThreshold && accelMagnitude > lastFilteredAccel) {
                    state = State.RISING
                    Timber.v("State: IDLE -> RISING (accel: $accelMagnitude)")
                }
            }
            
            State.RISING -> {
                if (accelMagnitude < lastFilteredAccel) {
                    // Transition to PEAK when acceleration starts decreasing
                    // Enhanced: Only transition if we've reached a significant peak
                    if (lastFilteredAccel > peakThreshold * 1.05f) {
                        state = State.PEAK
                        peakValue = lastFilteredAccel
                        peakTime = timeMs
                        Timber.v("State: RISING -> PEAK, peak value: $peakValue")
                    } else {
                        // Not a significant peak, go back to IDLE
                        state = State.IDLE
                        Timber.v("Insignificant peak detected, returning to IDLE")
                    }
                }
            }
            
            State.PEAK -> {
                // Enhanced: Track the highest peak value
                if (accelMagnitude > peakValue) {
                    peakValue = accelMagnitude
                    Timber.v("Updated peak value: $peakValue")
                }
                
                if (accelMagnitude < valleyThreshold) {
                    // Transition to FALLING when acceleration drops below valley threshold
                    state = State.FALLING
                    Timber.v("State: PEAK -> FALLING")
                }
            }
            
            State.FALLING -> {
                if (accelMagnitude > lastFilteredAccel) {
                    // Transition to VALLEY when acceleration starts increasing
                    state = State.VALLEY
                    valleyValue = lastFilteredAccel
                    valleyTime = timeMs
                    Timber.v("State: FALLING -> VALLEY, valley value: $valleyValue")
                    
                    val peakDuration = valleyTime - peakTime
                    val peakValleyHeight = peakValue - valleyValue
                    val timeSinceLastStep = timeMs - lastStepTime
                    
                    // Enhanced validation with weighted scoring system
                    var stepScore = 0.0f
                    
                    // Score based on peak-valley height (0-40 points)
                    val heightScore = ((peakValleyHeight - minPeakValleyHeight) / minPeakValleyHeight * 40f)
                        .coerceIn(0f, 40f)
                    
                    // Score based on timing (0-30 points)
                    val timingScore = if (timeSinceLastStep in minStepInterval..maxStepInterval) {
                        // Higher score for more "natural" step intervals (around 500-700ms)
                        val optimalInterval = (minStepInterval + maxStepInterval) / 2f
                        val deviation = abs(timeSinceLastStep - optimalInterval) / optimalInterval
                        (30f * (1f - deviation)).coerceIn(0f, 30f)
                    } else {
                        0f
                    }
                    
                    // Score based on gyroscope data (0-20 points)
                    val gyroScore = ((gyroMagnitude - gyroThreshold) / gyroThreshold * 20f)
                        .coerceIn(0f, 20f)
                    
                    // Score based on peak duration (0-10 points)
                    val durationScore = if (peakDuration in minPeakDuration..maxPeakDuration) {
                        // Higher score for more "natural" peak durations (around 200-300ms)
                        val optimalDuration = (minPeakDuration + maxPeakDuration) / 2f
                        val deviation = abs(peakDuration - optimalDuration) / optimalDuration
                        (10f * (1f - deviation)).coerceIn(0f, 10f)
                    } else {
                        0f
                    }
                    
                    // Calculate total score
                    stepScore = heightScore + timingScore + gyroScore + durationScore
                    
                    // Log detailed scoring for debugging
                    Timber.v("Step score: $stepScore (height: $heightScore, timing: $timingScore, gyro: $gyroScore, duration: $durationScore)")
                    
                    // Check if we have a valid step pattern with enhanced validation
                    if (stepScore >= 60f && // Require at least 60/100 points
                        peakValleyHeight >= minPeakValleyHeight &&
                        timeSinceLastStep >= minStepInterval &&
                        timeSinceLastStep <= maxStepInterval &&
                        gyroMagnitude >= gyroThreshold &&
                        peakDuration >= minPeakDuration &&
                        peakDuration <= maxPeakDuration) {
                        
                        // Step detected!
                        stepDetected = true
                        lastStepTime = timeMs
                        
                        Timber.d("Step detected at $timeMs ms, score: $stepScore, peak-valley height: $peakValleyHeight, gyro: $gyroMagnitude, peak duration: $peakDuration")
                    } else {
                        Timber.v("Step candidate rejected: score=$stepScore, height=$peakValleyHeight, interval=$timeSinceLastStep, gyro=$gyroMagnitude, duration=$peakDuration")
                    }
                    
                    // Reset to IDLE to start looking for the next step
                    state = State.IDLE
                }
            }
            
            State.VALLEY -> {
                // This state is transitional, we immediately move back to IDLE
                state = State.IDLE
                Timber.v("State: VALLEY -> IDLE")
            }
            
            // This should never happen, but is needed to make the when expression exhaustive
            else -> {
                Timber.e("Invalid state: $state")
                state = State.IDLE
            }
        }
        
        return stepDetected
    }
    
    /**
     * Resets the step detection state.
     * 
     * This method resets all internal state variables to their initial values,
     * effectively restarting the step detection process. This is useful when
     * the user's activity changes significantly (e.g., from walking to running)
     * or when the device position changes.
     */
    fun reset() {
        state = State.IDLE
        stepCount = 0
        lastStepTime = 0L
        peakValue = 0f
        valleyValue = 0f
        lastFilteredAccel = 0f
        lastFilteredGyro = 0f
        recentAccelValues.clear()
    }
    
    /**
     * Parameters for the AdvancedStepDetectionUseCase.
     * 
     * @param accelerometerData Accelerometer data containing x, y, z values and timestamp
     * @param gyroscopeData Optional gyroscope data for improved step detection accuracy
     * @param accelFilterAlpha Low-pass filter coefficient for accelerometer data (0-1)
     * @param gyroFilterAlpha Low-pass filter coefficient for gyroscope data (0-1)
     * @param peakThreshold Threshold for peak detection in acceleration magnitude
     * @param valleyThreshold Threshold for valley detection in acceleration magnitude
     * @param minPeakValleyHeight Minimum height difference between peak and valley to consider a valid step
     * @param minStepInterval Minimum time between steps in milliseconds (250ms = max 4 steps per second)
     * @param maxStepInterval Maximum time between steps in milliseconds (2000ms = min 0.5 steps per second)
     * @param gyroThreshold Minimum gyroscope magnitude required to validate a step detection
     * @param minPeakDuration Minimum duration of a peak in milliseconds
     * @param maxPeakDuration Maximum duration of a peak in milliseconds
     */
    data class Params(
        val accelerometerData: SensorData.Accelerometer,
        val gyroscopeData: SensorData.Gyroscope? = null,
        val accelFilterAlpha: Float = 0.2f,
        val gyroFilterAlpha: Float = 0.3f,
        val peakThreshold: Float = 10.5f,
        val valleyThreshold: Float = 9.5f,
        val minPeakValleyHeight: Float = 0.7f,
        val minStepInterval: Long = 250,
        val maxStepInterval: Long = 2000,
        val gyroThreshold: Float = 0.2f,
        val minPeakDuration: Long = 60,
        val maxPeakDuration: Long = 500
    )
    
    /**
     * Result of the advanced step detection.
     * 
     * This class encapsulates all the information about the step detection result,
     * including whether a step was detected, the current step count, filtered sensor
     * values, the current state of the detection state machine, and the timestamp.
     * 
     * @param stepDetected True if a step was detected in this invocation
     * @param stepCount Total number of steps detected since the last reset
     * @param filteredAcceleration Current filtered acceleration magnitude
     * @param filteredGyroMagnitude Current filtered gyroscope magnitude
     * @param currentState Current state of the step detection state machine
     * @param timestamp Timestamp of the detection in nanoseconds
     */
    data class Result(
        val stepDetected: Boolean,
        val stepCount: Int,
        val filteredAcceleration: Float,
        val filteredGyroMagnitude: Float,
        val currentState: String,
        val timestamp: Long
    )
    
    companion object {
        /**
         * Window size for adaptive thresholding.
         */
        const val WINDOW_SIZE = 50
        
        /**
         * Default accelerometer filter alpha value.
         */
        const val DEFAULT_ACCEL_FILTER_ALPHA = 0.2f
        
        /**
         * Default gyroscope filter alpha value.
         */
        const val DEFAULT_GYRO_FILTER_ALPHA = 0.3f
        
        /**
         * Default gyroscope threshold for step validation.
         */
        const val DEFAULT_GYRO_THRESHOLD = 0.2f
    }
}